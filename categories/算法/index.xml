<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Neo&#39;s Blog</title>
    <link>https://neowyj.github.io/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Neo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 01 Nov 2019 18:04:43 +0000</lastBuildDate><atom:link href="https://neowyj.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A*算法</title>
      <link>https://neowyj.github.io/post/a%E6%98%9F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 01 Nov 2019 18:04:43 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/a%E6%98%9F%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h4 id=&#34;算法简介&#34;&gt;算法简介&lt;/h4&gt;
&lt;p&gt;A星搜索算法（A* search algorithm），简称A星算法，是一种启发式搜索算法，用于求解图中两个节点之间的最短路径及其长度。常用于游戏中NPC的移动计算和求地图中两点的实际最短路径。A星算法是Dijkstra算法的升级版，但Dijkstra算法属于盲目搜索，每次都需要访问到所有结点的路径并找出最短的一条路径，然后以该最短路径为基础更新到其他结点的路径，不断重复直到找到所有的最短路径结点。当图中的结点很多时，如果采用Dijkstra算法寻找最短路径，产生的计算量将会非常大，而采用A星算法产生的计算量将会远小于Dijkstra算法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://neowyj.github.io/post/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 13 Oct 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;h4 id=&#34;排序概述&#34;&gt;&lt;strong&gt;排序概述&lt;/strong&gt;&lt;/h4&gt;
&lt;h6 id=&#34;基本概念&#34;&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;：重新排列表中元素，使其按关键字递增或递减的过程，一般是递增的。排序算法是数据结构中最基础的算法之一。&lt;strong&gt;排序算法的稳定性：&lt;strong&gt;如果a=b且排序前a在b的前面，使用某一排序算法排序后a依然在b的前面，就称这个排序算法是&lt;/strong&gt;稳定&lt;/strong&gt;的。反之，则称该排序算法是&lt;strong&gt;不稳定&lt;/strong&gt;的。注意，算法是否具有稳定性并不能衡量一个算法的优劣，它只是对一个算法的性质进行描述。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>查找</title>
      <link>https://neowyj.github.io/post/%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Thu, 26 Sep 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E6%9F%A5%E6%89%BE/</guid>
      <description>&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;：在数据集合中寻找满足某种条件的数据元素的过程称为查找。&lt;strong&gt;查找表&lt;/strong&gt;：用于查找的数据结合称为查找表，它是由同一类型的数据元素（记录）组成，可以是一个数组或链表等数据类型。&lt;strong&gt;静态查找表&lt;/strong&gt;：只用于查找某个元素和检索满足某个条件的数据元素的各种属性的查找表称为静态查找表。&lt;strong&gt;动态查找表&lt;/strong&gt;：在静态查找表基础上，需要动态地插入和删除元素的查找表称为动态查找表。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dijkstra算法及堆优化</title>
      <link>https://neowyj.github.io/post/dijkstra%E7%AE%97%E6%B3%95%E5%8F%8A%E5%A0%86%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 17 Sep 2019 17:00:16 +0800</pubDate>
      
      <guid>https://neowyj.github.io/post/dijkstra%E7%AE%97%E6%B3%95%E5%8F%8A%E5%A0%86%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h4 id=&#34;简介&#34;&gt;简介&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra&lt;/strong&gt;（迪杰斯特拉）算法主要用于求解&lt;strong&gt;非负权图&lt;/strong&gt;中单源最短路径问题，即求一个顶点到图中其他顶点之间的最短路径。对于负权图的单源路径问题，一般采用&lt;strong&gt;Bellman–Ford&lt;/strong&gt;（贝尔曼-福特）算法进行求解。对于非负权图，Dijkstra算法是目前已知的最快的单源路径算法，该算法常用于路由算法或者作为其他图算法的子模块。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>栈和队列</title>
      <link>https://neowyj.github.io/post/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 20 Jul 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;h4 id=&#34;简介&#34;&gt;简介&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/006WUoxdgy1g7sxht6f0oj30ba08wju0.jpg&#34; style=&#34;zoom:80%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;（Stack），又称堆栈，是只允许在一端进行插入和删除的线性表，即栈是受限线性表。允许插入和删除的一端称为&lt;strong&gt;栈顶&lt;/strong&gt;（Top），不允许插入和删除的一端称为&lt;strong&gt;栈底&lt;/strong&gt;（Bottom），栈底是固定的。栈的操作特点是后进先出&lt;strong&gt;LIFO&lt;/strong&gt;（Last In First Out），故又称后进先出的线性表。&lt;strong&gt;空栈&lt;/strong&gt;是不含任何元素的栈。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://neowyj.github.io/post/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 27 Jun 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;h4 id=&#34;简介&#34;&gt;简介&lt;/h4&gt;
&lt;p&gt;链表（LinkedList）是一种物理存储结构上非连续的线性表结构，数据元素的逻辑顺序通过链表中的指针链接次序来实现。实际上，链表就是线性表的&lt;strong&gt;链式存储结构&lt;/strong&gt;。链表是由一系列结点组成，链表中每一个数据元素表示一个节点，节点可以在运行时动态生成。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://neowyj.github.io/post/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 20 Jun 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;h4 id=&#34;简介&#34;&gt;简介&lt;/h4&gt;
&lt;p&gt;数组（Array）是由相同类型的元素的集合所组成的数据结构。数组采用一块连续的内存空间来存储数据，利用数组下标索引可以随机存取对应的元素。数组元素的类型除了int、float、double和char等基本类型，还可以是类、枚举和结构体等复杂类型。借助数组可以实现线性表的&lt;strong&gt;顺序存储结构&lt;/strong&gt;（即顺序表）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>算法效率</title>
      <link>https://neowyj.github.io/post/%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/</link>
      <pubDate>Sun, 26 May 2019 22:04:41 +0000</pubDate>
      
      <guid>https://neowyj.github.io/post/%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/</guid>
      <description>&lt;h4 id=&#34;序言&#34;&gt;序言&lt;/h4&gt;
&lt;p&gt;掌握常用数据结构和算法是每一位程序员最基本的能力之一。在软件开发领域，**“数据结构+算法=程序”**是大多数开发者的共识，这足以说明数据结构和算法的重要性。数据结构和算法不受编程语言限制，绝大多数编程语言都可以实现大部分的数据结构和算法。掌握常用数据结构和算法可以使我们能够高效地解决一些特定场景的复杂问题。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
